plugins {
    id 'application'
    // Already defined in buildSrc, no version
    id 'com.github.johnrengelman.shadow' apply false
}

import com.github.jengelman.gradle.plugins.shadow.relocation.RelocateClassContext
import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import java.util.jar.JarFile

ext {
    deployDir = 'Makanism'
}

copy {
    IncludedBuild base = gradle.includedBuild('Makanism')
    from "${base.projectDir}/dependencies.gradle"
    from "${base.projectDir}/extern.gradle"
    into rootDir
}
apply from: 'dependencies.gradle'
apply from: 'extern.gradle'

dependencies {
    gradle.ext.modules.forEach { String module ->
        implementation project(module)
    }
}

subprojects {
    apply plugin: 'com.github.johnrengelman.shadow'

    configurations {
        extern
        compile.extendsFrom extern
    }

    def packages = [] as Set<String>
    task searchExternPackages {
        onlyIf { packages.empty }
        doFirst {
            // do it without setting configuration property
            // so dependencies won't get included in the jar
            project.configurations.extern.files.each { jar ->
                JarFile jf = new JarFile(jar)
                jf.entries().each { entry ->
                    if (entry.name.endsWith(".class")) {
                        packages << entry.name[0..entry.name.lastIndexOf('/') - 1].replaceAll('/', '.')
                    }
                }
                jf.close()
            }
        }
    }

    task moduleJar(type: ShadowJar) {
        dependsOn tasks.classes, tasks.searchExternPackages
        inputs.files(sourceSets.main.output)

        def depShadePrefix = "deps_$project.name".replace('-','_')
        afterEvaluate {
            def deployDir = rootProject.ext.deployDir
            def libName = project.name
            def libVersion = DEFAULT_VERSION == project.version ? 'unversioned' : project.version
            def libExtension = 'jar'

            def libFileName = "$libName-$libVersion.$libExtension"
            def destDir = "$rootProject.projectDir/$deployDir/modules"

            archiveFileName = libFileName
            destinationDirectory = file(destDir)

            delete fileTree(destDir) {
                include "$libName-*.$libExtension"
                exclude libFileName
            }
            outputs.file("$destDir/$libFileName")
        }
        doFirst {
            from(sourceSets.main.output)
            exclude 'module-info.class'
            packages.each {
                relocate(it, "${depShadePrefix}.${it}")
            }
        }
    }

    task services(type: ServiceFileCreator){
        outputs.upToDateWhen { false }
        doFirst {
            target = tasks.moduleJar as Jar
        }
    }

    tasks.moduleJar.dependsOn tasks.services

    task depsJar(type: ShadowJar) {
        dependsOn tasks.searchExternPackages
        mergeServiceFiles()
        transform(PropertiesValuesTransformer.class) {
            valueTransformer = { v ->
                String relocated = v
                relocators.each { rel ->
                    if (rel.canRelocateClass(v)) {
                        def vContext = RelocateClassContext.builder().className(v).stats(stats).build()
                        relocated = rel.relocateClass(vContext)
                    }
                }
                return relocated
            }
        }

        def depShadePrefix = "deps_$project.name".replace('-', '_')
        afterEvaluate {
            def deployDir = rootProject.ext.deployDir
            def libName = project.name
            def libExtension = 'jar'

            def libFileName = "$libName-deps.$libExtension"
            def destDir = "$rootProject.projectDir/$deployDir/modules/lib"

            archiveFileName = libFileName
            destinationDirectory = file(destDir)

            inputs.files(project.configurations.extern)
            outputs.file("$destDir/$libFileName")
        }
        doFirst {
            configurations = [project.configurations.extern]
            exclude 'module-info.class'
            packages.each {
                relocate(it, "${depShadePrefix}.${it}")
            }
        }
    }
}

jar.enabled = false     // disable jar creation for root project

distZip.enabled = false
distTar.enabled = false

task buildBase {
    String deploy = "$rootDir/$project.ext.deployDir"
    mkdir "$deploy"
    mkdir "$deploy/$outputLibDir"
    mkdir "$deploy/config"

    IncludedBuild base = gradle.includedBuild('Makanism')
    dependsOn base.task(':buildOutput')
    shouldRunAfter base.task(':buildOutput')

    inputs .dir("$base.projectDir/$outputDir/$outputLibDir")
    inputs .file("$base.projectDir/$outputDir/$bot_archive_name")
    outputs.dir("$deploy/$outputLibDir")
    outputs.file("$deploy/$bot_archive_name")

    doLast {
        println "Deleting old files..."
        delete {
           delete "$deploy/$outputLibDir"
        }
        println "Copying from $base.projectDir/$outputDir..."
        copy {
            from "$base.projectDir/$outputDir"
            into deploy
        }
    }
}

task buildModules {
    shouldRunAfter tasks.buildBase
    String modulesDir = "$rootDir/$project.ext.deployDir/modules"
    mkdir modulesDir
    mkdir "$modulesDir/lib"

    inputs .dir(modulesDir)
    outputs.dir(modulesDir)

    subprojects.each {
        dependsOn it.tasks.depsJar, it.tasks.moduleJar
    }
}

task buildModulesOnly {
    String modulesDir = "$rootDir/$project.ext.deployDir/modules"
    mkdir modulesDir
    mkdir "$modulesDir/lib"

    inputs .dir(modulesDir)
    outputs.dir(modulesDir)

    subprojects.each {
        dependsOn it.tasks.moduleJar
    }
}

task setup {
    dependsOn tasks.buildModules, tasks.buildBase
}

task setupWithoutDepsJars {
    dependsOn tasks.buildModulesOnly, tasks.buildBase
}

task createStartScripts(type: CreateStartScripts) {
    outputs.upToDateWhen { false }      // never skip

    defaultJvmOpts = ["-Xmx200M", "-Xms200M", "-cp Makanism.jar;modules/lib/*", "-Dlog4j.skipJansi=false"]
    outputDir = file("$rootDir/$deployDir")
    mainClass.set(bot_main_class as String)
    applicationName = bot_name

    unixStartScriptGenerator.template = resources.text.fromFile("$rootDir/resources/unix_template.txt")
    windowsStartScriptGenerator.template = resources.text.fromFile("$rootDir/resources/windows_template.txt")
}
