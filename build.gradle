import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import java.util.jar.JarFile

plugins {
    id 'application'
    id 'com.github.johnrengelman.shadow' version '6.0.0' apply false
}

ext {
    deployDir = 'Makanism'
}

copy {
    IncludedBuild base = gradle.includedBuild('Makanism')
    from "${base.projectDir}/dependencies.gradle"
    from "${base.projectDir}/extern.gradle"
    into rootDir
}
apply from: 'dependencies.gradle'
apply from: 'extern.gradle'

dependencies {
    gradle.ext.modules.forEach { String module ->
        implementation project(module)
    }
}

class ServiceFileCreator extends DefaultTask {

    @Input
    int cacheHash = -1

    @OutputDirectory
    File generatedFilesDir = project.file("$project.buildDir/generated/services")

    private String provides
    protected Map<String, String> serviceProviders = [:]

    Jar target

    @TaskAction
    def execute(){
        this.target.metaInf {
            serviceProviders.each { service, content ->
                File file = new File(this.generatedFilesDir, service)
                file.text = content
                from(file) {
                    into "services"
                }
            }
        }
    }

    /**
     * The class path of the service interface that is implemented
     * @param clazz Class path of the service interface that is implemented
     * @return this
     */
    @Input
    ServiceFileCreator provides(String clazz){
        Objects.requireNonNull(clazz)
        this.provides = clazz
        cacheHash = Objects.hash(cacheHash, clazz)
        return this
    }

    /**
     * The class path of the service provider
     * @param clazz Class path of the service provider
     */
    @Input
    void with(String clazz){
        if (this.provides){
            cacheHash = Objects.hash(cacheHash, clazz)
            if (!this.serviceProviders[this.provides])
                this.serviceProviders[this.provides] = clazz + '\n'
            else
                this.serviceProviders[this.provides] = this.serviceProviders[this.provides] + clazz + '\n'
            this.provides = null
        }
    }
}

subprojects {
    apply plugin: 'com.github.johnrengelman.shadow'

    configurations {
        extern
        compile.extendsFrom extern
    }

    def packages = [] as Set<String>
    task searchExternPackages {
        onlyIf { packages.empty }
        doFirst {
            // do it without setting configuration property
            // so dependencies won't get included in the jar
            project.configurations.extern.files.each { jar ->
                JarFile jf = new JarFile(jar)
                jf.entries().each { entry ->
                    if (entry.name.endsWith(".class")) {
                        packages << entry.name[0..entry.name.lastIndexOf('/') - 1].replaceAll('/', '.')
                    }
                }
                jf.close()
            }
        }
    }

    task moduleJar(type: ShadowJar) {
        dependsOn tasks.classes, tasks.searchExternPackages
        inputs.files(sourceSets.main.output)

        def depShadePrefix = "deps_$project.name".replace('-','_')
        afterEvaluate {
            def deployDir = rootProject.ext.deployDir
            def libName = project.name
            def libVersion = DEFAULT_VERSION == project.version ? 'unversioned' : project.version
            def libExtension = 'jar'

            def libFileName = "$libName-$libVersion.$libExtension"
            def destDir = "$rootProject.projectDir/$deployDir/modules"

            archiveFileName = libFileName
            destinationDirectory = file(destDir)

            delete fileTree(destDir) {
                include "$libName-*.$libExtension"
                exclude libFileName
            }
            outputs.file("$destDir/$libFileName")
        }
        doFirst {
            from(sourceSets.main.output)
            exclude 'module-info.class'
            packages.each {
                relocate(it, "${depShadePrefix}.${it}")
            }
        }
    }

    task services(type: ServiceFileCreator){
        outputs.upToDateWhen { false }
        doFirst {
            target = tasks.moduleJar as Jar
        }
    }

    tasks.moduleJar.dependsOn tasks.services

    // NOTE: Dependency-provided services is currently broken until ShadowJar supports service file relocation
    task depsJar(type: ShadowJar) {
        dependsOn tasks.searchExternPackages

        def depShadePrefix = "deps_$project.name".replace('-', '_')
        afterEvaluate {
            def deployDir = rootProject.ext.deployDir
            def libName = project.name
            def libExtension = 'jar'

            def libFileName = "$libName-deps.$libExtension"
            def destDir = "$rootProject.projectDir/$deployDir/modules/lib"

            archiveFileName = libFileName
            destinationDirectory = file(destDir)

            inputs.files(project.configurations.extern)
            outputs.file("$destDir/$libFileName")
        }
        doFirst {
            configurations = [project.configurations.extern]
            exclude 'module-info.class'
            packages.each {
                relocate(it, "${depShadePrefix}.${it}")
            }
        }
    }
}

jar.enabled = false     // disable jar creation for root project

distZip.enabled = false
distTar.enabled = false

task buildBase {
    String deploy = "$rootDir/$project.ext.deployDir"
    mkdir "$deploy"
    mkdir "$deploy/$outputLibDir"
    mkdir "$deploy/config"

    IncludedBuild base = gradle.includedBuild('Makanism')
    dependsOn base.task(':buildOutput')
    shouldRunAfter base.task(':buildOutput')

    inputs .dir("$base.projectDir/$outputDir/$outputLibDir")
    inputs .file("$base.projectDir/$outputDir/$bot_archive_name")
    outputs.dir("$deploy/$outputLibDir")
    outputs.file("$deploy/$bot_archive_name")

    doLast {
        println "Deleting old files..."
        delete {
           delete "$deploy/$outputLibDir"
        }
        println "Copying from $base.projectDir/$outputDir..."
        copy {
            from "$base.projectDir/$outputDir"
            into deploy
        }
    }
}

task buildModules {
    shouldRunAfter tasks.buildBase
    String modulesDir = "$rootDir/$project.ext.deployDir/modules"
    mkdir modulesDir
    mkdir "$modulesDir/lib"

    inputs .dir(modulesDir)
    outputs.dir(modulesDir)

    subprojects.each {
        dependsOn it.tasks.depsJar, it.tasks.moduleJar
    }
}

task setup {
    dependsOn tasks.buildModules, tasks.buildBase
}

task createStartScripts(type: CreateStartScripts) {
    outputs.upToDateWhen { false }      // never skip

    defaultJvmOpts = ["-Xmx200M", "-Xms200M", "-cp Makanism.jar;modules/*;modules/lib/*", "-Dlog4j.skipJansi=false"]
    outputDir = file("$rootDir/$deployDir")
    mainClass.set(bot_main_class as String)
    applicationName = bot_name

    unixStartScriptGenerator.template = resources.text.fromFile("$rootDir/resources/unix_template.txt")
    windowsStartScriptGenerator.template = resources.text.fromFile("$rootDir/resources/windows_template.txt")
}
